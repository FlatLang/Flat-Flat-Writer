package flat/writer/flat

import flat/ast
import flat/ast/visitor
import flat/compiler/models/Token
import flat/io
import flat/log/Logger
import flat/eventstream/EventStream
import flat/writer

class extends VisitorBase {
  static FileNodeWriter fileNodeWriter = FileNodeWriter()
  static PackageNodeWriter packageNodeWriter = PackageNodeWriter()
  static ImportNodeWriter importNodeWriter = ImportNodeWriter()
  static AnnotationNodeWriter annotationNodeWriter = AnnotationNodeWriter()
  static ClassNodeWriter classNodeWriter = ClassNodeWriter()
  static FunctionNodeWriter functionNodeWriter = FunctionNodeWriter()
  static LocalDeclarationNodeWriter localDeclarationNodeWriter = LocalDeclarationNodeWriter()
  static AssignmentNodeWriter assignmentNodeWriter = AssignmentNodeWriter()
  static FunctionCallNodeWriter functionCallNodeWriter = FunctionCallNodeWriter()
  static IdentifierNodeWriter identifierNodeWriter = IdentifierNodeWriter()
  static DotAccessNodeWriter dotAccessNodeWriter = DotAccessNodeWriter()
  static LiteralNodeWriter literalNodeWriter = LiteralNodeWriter()

  public construct(private OutputStream outputStream) {}

  override public visit(Node node) {
    let type = node.class

    if (type.isOfType(FileNode.class)) fileNodeWriter.write((FileNode)node, outputStream)
    else if (type.isOfType(PackageNode.class)) packageNodeWriter.write((PackageNode)node, outputStream)
    else if (type.isOfType(ImportNode.class)) importNodeWriter.write((ImportNode)node, outputStream)
    else if (type.isOfType(AnnotationNode.class)) annotationNodeWriter.write((AnnotationNode)node, outputStream)
    else if (type.isOfType(ClassNode.class)) classNodeWriter.write((ClassNode)node, outputStream)
    else if (type.isOfType(FunctionNode.class)) functionNodeWriter.write((FunctionNode)node, outputStream)
    else if (type.isOfType(LocalDeclarationNode.class)) localDeclarationNodeWriter.write((LocalDeclarationNode)node, outputStream)
    else if (type.isOfType(AssignmentNode.class)) assignmentNodeWriter.write((AssignmentNode)node, outputStream)
    else if (type.isOfType(FunctionCallNode.class)) functionCallNodeWriter.write((FunctionCallNode)node, outputStream)
    else if (type.isOfType(IdentifierNode.class)) identifierNodeWriter.write((IdentifierNode)node, outputStream)
    else if (type.isOfType(DotAccessNode.class)) dotAccessNodeWriter.write((DotAccessNode)node, outputStream)
    else if (type.isOfType(LiteralNode.class)) literalNodeWriter.write((LiteralNode)node, outputStream)
    else throw Exception("Unsupported node type: #{node.class}")
  }
}
